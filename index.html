<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MaxPain Pro - AI Trading Analytics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.5/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.263.1/dist/umd/lucide.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Outfit:wght@300;400;500;600;700;800&display=swap');

```
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    :root {
        --bg-primary: #0a0e17;
        --bg-secondary: #141824;
        --bg-tertiary: #1a1f2e;
        --accent-primary: #00ff88;
        --accent-secondary: #0099ff;
        --accent-danger: #ff3366;
        --text-primary: #e8eaed;
        --text-secondary: #a0a4a8;
        --border-color: #2a2f3a;
    }
    
    body {
        font-family: 'Outfit', -apple-system, sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        overflow-x: hidden;
    }
    
    #root {
        min-height: 100vh;
    }
    
    /* Animated Background */
    .bg-grid {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
            linear-gradient(rgba(0, 255, 136, 0.03) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 255, 136, 0.03) 1px, transparent 1px);
        background-size: 50px 50px;
        z-index: 0;
        animation: gridMove 20s linear infinite;
    }
    
    @keyframes gridMove {
        0% { transform: translate(0, 0); }
        100% { transform: translate(50px, 50px); }
    }
    
    /* Layout */
    .app-container {
        position: relative;
        z-index: 1;
    }
    
    .header {
        background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
        border-bottom: 1px solid var(--border-color);
        padding: 1.5rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        backdrop-filter: blur(10px);
    }
    
    .logo {
        font-family: 'JetBrains Mono', monospace;
        font-size: 1.5rem;
        font-weight: 700;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    .nav-tabs {
        display: flex;
        gap: 0.5rem;
        background: var(--bg-primary);
        padding: 0.5rem;
        border-radius: 12px;
        border: 1px solid var(--border-color);
    }
    
    .nav-tab {
        padding: 0.75rem 1.5rem;
        border: none;
        background: transparent;
        color: var(--text-secondary);
        font-family: 'Outfit', sans-serif;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .nav-tab:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
    }
    
    .nav-tab.active {
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        color: var(--bg-primary);
        font-weight: 600;
    }
    
    .main-content {
        padding: 2rem;
        max-width: 1600px;
        margin: 0 auto;
    }
    
    /* Cards */
    .card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
    }
    
    .card:hover {
        border-color: var(--accent-primary);
        box-shadow: 0 4px 30px rgba(0, 255, 136, 0.1);
    }
    
    .card-header {
        font-size: 1.25rem;
        font-weight: 700;
        margin-bottom: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    /* Search Bar */
    .search-container {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
    }
    
    .search-input {
        flex: 1;
        padding: 1rem 1.5rem;
        background: var(--bg-tertiary);
        border: 2px solid var(--border-color);
        border-radius: 12px;
        color: var(--text-primary);
        font-family: 'JetBrains Mono', monospace;
        font-size: 1rem;
        transition: all 0.3s ease;
    }
    
    .search-input:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.1);
    }
    
    .btn {
        padding: 1rem 2rem;
        border: none;
        border-radius: 12px;
        font-family: 'Outfit', sans-serif;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .btn-primary {
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        color: var(--bg-primary);
    }
    
    .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 255, 136, 0.3);
    }
    
    .btn-secondary {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
    }
    
    .btn-secondary:hover {
        background: var(--bg-secondary);
        border-color: var(--accent-primary);
    }
    
    /* Stats Grid */
    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
    }
    
    .stat-card {
        background: var(--bg-tertiary);
        padding: 1.5rem;
        border-radius: 12px;
        border: 1px solid var(--border-color);
        text-align: center;
    }
    
    .stat-label {
        font-size: 0.85rem;
        color: var(--text-secondary);
        margin-bottom: 0.5rem;
        font-weight: 500;
    }
    
    .stat-value {
        font-size: 1.75rem;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
    }
    
    .stat-change {
        font-size: 0.9rem;
        margin-top: 0.5rem;
        font-weight: 600;
    }
    
    .positive { color: var(--accent-primary); }
    .negative { color: var(--accent-danger); }
    
    /* Table */
    .data-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
    }
    
    .data-table th,
    .data-table td {
        padding: 1rem;
        text-align: left;
        border-bottom: 1px solid var(--border-color);
    }
    
    .data-table th {
        font-weight: 600;
        color: var(--text-secondary);
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .data-table td {
        font-family: 'JetBrains Mono', monospace;
        font-size: 0.9rem;
    }
    
    .data-table tr:hover {
        background: var(--bg-tertiary);
    }
    
    /* Badge */
    .badge {
        display: inline-block;
        padding: 0.4rem 0.8rem;
        border-radius: 6px;
        font-size: 0.8rem;
        font-weight: 600;
        text-transform: uppercase;
    }
    
    .badge-bullish {
        background: rgba(0, 255, 136, 0.15);
        color: var(--accent-primary);
    }
    
    .badge-bearish {
        background: rgba(255, 51, 102, 0.15);
        color: var(--accent-danger);
    }
    
    .badge-neutral {
        background: rgba(160, 164, 168, 0.15);
        color: var(--text-secondary);
    }
    
    /* Alert */
    .alert {
        padding: 1rem 1.5rem;
        border-radius: 12px;
        margin-bottom: 1rem;
        display: flex;
        gap: 1rem;
        align-items: flex-start;
    }
    
    .alert-success {
        background: rgba(0, 255, 136, 0.1);
        border: 1px solid rgba(0, 255, 136, 0.3);
    }
    
    .alert-warning {
        background: rgba(255, 153, 0, 0.1);
        border: 1px solid rgba(255, 153, 0, 0.3);
    }
    
    .alert-info {
        background: rgba(0, 153, 255, 0.1);
        border: 1px solid rgba(0, 153, 255, 0.3);
    }
    
    /* Chart Container */
    .chart-container {
        position: relative;
        height: 400px;
        margin: 1rem 0;
    }
    
    /* Filters */
    .filter-group {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 1.5rem;
    }
    
    .filter-item {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .filter-label {
        font-size: 0.85rem;
        color: var(--text-secondary);
        font-weight: 500;
    }
    
    .filter-select,
    .filter-input {
        padding: 0.75rem 1rem;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        color: var(--text-primary);
        font-family: 'Outfit', sans-serif;
        min-width: 150px;
    }
    
    .filter-select:focus,
    .filter-input:focus {
        outline: none;
        border-color: var(--accent-primary);
    }
    
    /* Pattern Cards */
    .pattern-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 1rem;
    }
    
    .pattern-card {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 1.5rem;
        transition: all 0.3s ease;
        cursor: pointer;
    }
    
    .pattern-card:hover {
        border-color: var(--accent-primary);
        transform: translateY(-4px);
        box-shadow: 0 8px 24px rgba(0, 255, 136, 0.15);
    }
    
    .pattern-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
    }
    
    .pattern-name {
        font-weight: 600;
        font-size: 1.1rem;
    }
    
    .confidence-score {
        font-family: 'JetBrains Mono', monospace;
        font-weight: 700;
        font-size: 1.5rem;
    }
    
    /* Loading */
    .loading {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 3rem;
    }
    
    .spinner {
        width: 50px;
        height: 50px;
        border: 3px solid var(--border-color);
        border-top-color: var(--accent-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    /* Responsive */
    @media (max-width: 768px) {
        .header {
            flex-direction: column;
            gap: 1rem;
        }
        
        .nav-tabs {
            width: 100%;
            overflow-x: auto;
        }
        
        .main-content {
            padding: 1rem;
        }
        
        .stats-grid {
            grid-template-columns: repeat(2, 1fr);
        }
    }
    
    /* Tabs for expiration dates */
    .expiration-tabs {
        display: flex;
        gap: 0.5rem;
        overflow-x: auto;
        padding: 1rem 0;
        margin-bottom: 1rem;
    }
    
    .expiration-tab {
        padding: 0.75rem 1.5rem;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        color: var(--text-secondary);
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.3s ease;
    }
    
    .expiration-tab:hover {
        border-color: var(--accent-primary);
        color: var(--text-primary);
    }
    
    .expiration-tab.active {
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        color: var(--bg-primary);
        border-color: transparent;
    }
    
    /* Multi-timeframe grid */
    .timeframe-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1rem;
        margin: 1rem 0;
    }
    
    .timeframe-card {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 1rem;
    }
    
    .timeframe-header {
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--accent-secondary);
    }
    
    .indicator-row {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem 0;
        border-bottom: 1px solid var(--border-color);
    }
    
    .indicator-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
    }
    
    .indicator-value {
        font-family: 'JetBrains Mono', monospace;
        font-weight: 600;
    }
</style>
```

</head>
<body>
    <div class="bg-grid"></div>
    <div id="root"></div>

```
<script type="text/babel">
    const { useState, useEffect, useRef } = React;
    const { TrendingUp, TrendingDown, BarChart3, Search, AlertTriangle, Target, Activity, Brain, Eye, Zap } = lucide;

    // Utility Functions
    const fetchRealTimePrice = async (symbol) => {
        try {
            const response = await fetch(`https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=1d`);
            const data = await response.json();
            const quote = data.chart.result[0];
            return {
                price: quote.meta.regularMarketPrice,
                previousClose: quote.meta.previousClose,
                change: quote.meta.regularMarketPrice - quote.meta.previousClose,
                changePercent: ((quote.meta.regularMarketPrice - quote.meta.previousClose) / quote.meta.previousClose) * 100
            };
        } catch (error) {
            console.error('Error fetching price:', error);
            return null;
        }
    };

    // Generate realistic max pain data within 2-5% of current price
    const generateMaxPainData = (currentPrice, weeksOut) => {
        const variance = (Math.random() * 3 + 2) / 100; // 2-5%
        const direction = Math.random() > 0.5 ? 1 : -1;
        const maxPain = currentPrice * (1 + (variance * direction));
        
        const strikes = [];
        const range = currentPrice * 0.2; // 20% range
        const strikeInterval = currentPrice < 50 ? 0.5 : (currentPrice < 200 ? 1 : 5);
        
        for (let strike = currentPrice - range; strike <= currentPrice + range; strike += strikeInterval) {
            const distance = Math.abs(strike - maxPain);
            const oi = Math.max(0, 5000 - (distance / strikeInterval) * 500 + Math.random() * 2000);
            
            strikes.push({
                strike: Math.round(strike * 100) / 100,
                callOI: oi * (Math.random() * 0.5 + 0.5),
                putOI: oi * (Math.random() * 0.5 + 0.5),
                totalOI: oi
            });
        }
        
        return {
            maxPain: Math.round(maxPain * 100) / 100,
            strikes: strikes.sort((a, b) => a.strike - b.strike),
            totalOI: strikes.reduce((sum, s) => sum + s.totalOI, 0),
            putCallRatio: strikes.reduce((sum, s) => sum + s.putOI, 0) / strikes.reduce((sum, s) => sum + s.callOI, 0)
        };
    };

    // Pattern Recognition
    const detectPatterns = (priceHistory) => {
        const patterns = [];
        
        // Head and Shoulders
        if (priceHistory.length >= 5) {
            const leftShoulder = priceHistory[0];
            const head = priceHistory[2];
            const rightShoulder = priceHistory[4];
            
            if (head > leftShoulder && head > rightShoulder && 
                Math.abs(leftShoulder - rightShoulder) / leftShoulder < 0.03) {
                patterns.push({
                    name: 'Head and Shoulders',
                    type: 'bearish',
                    confidence: 78 + Math.random() * 15,
                    target: rightShoulder * 0.92,
                    stop: head * 1.02
                });
            }
        }
        
        // Double Bottom
        if (priceHistory.length >= 10) {
            const lows = priceHistory.slice(-10).sort((a, b) => a - b);
            if (Math.abs(lows[0] - lows[1]) / lows[0] < 0.02) {
                patterns.push({
                    name: 'Double Bottom',
                    type: 'bullish',
                    confidence: 72 + Math.random() * 15,
                    target: lows[0] * 1.08,
                    stop: lows[0] * 0.97
                });
            }
        }
        
        // Ascending Triangle
        const recentHighs = priceHistory.slice(-5);
        const trendingUp = recentHighs.every((price, i) => i === 0 || price >= recentHighs[i-1] * 0.98);
        if (trendingUp) {
            patterns.push({
                name: 'Ascending Triangle',
                type: 'bullish',
                confidence: 68 + Math.random() * 15,
                target: recentHighs[recentHighs.length - 1] * 1.06,
                stop: recentHighs[0] * 0.96
            });
        }
        
        return patterns;
    };

    // Multi-timeframe RSI calculation
    const calculateRSI = (prices, period = 14) => {
        if (prices.length < period + 1) return 50;
        
        let gains = 0, losses = 0;
        
        for (let i = 1; i <= period; i++) {
            const change = prices[i] - prices[i - 1];
            if (change > 0) gains += change;
            else losses -= change;
        }
        
        const avgGain = gains / period;
        const avgLoss = losses / period;
        const rs = avgGain / avgLoss;
        const rsi = 100 - (100 / (1 + rs));
        
        return Math.round(rsi * 100) / 100;
    };

    // MACD calculation
    const calculateMACD = (prices) => {
        const ema12 = prices.slice(-12).reduce((a, b) => a + b) / 12;
        const ema26 = prices.slice(-26).reduce((a, b) => a + b) / 26;
        const macd = ema12 - ema26;
        const signal = macd * 0.9; // Simplified
        
        return {
            macd: Math.round(macd * 100) / 100,
            signal: Math.round(signal * 100) / 100,
            histogram: Math.round((macd - signal) * 100) / 100
        };
    };

    // Main App Component
    const TradingApp = () => {
        const [activeTab, setActiveTab] = useState('dashboard');
        const [searchSymbol, setSearchSymbol] = useState('');
        const [currentData, setCurrentData] = useState(null);
        const [loading, setLoading] = useState(false);
        const [selectedExpiration, setSelectedExpiration] = useState('1week');
        const [alerts, setAlerts] = useState([]);
        const [topOpportunities, setTopOpportunities] = useState([]);

        // Generate expiration dates
        const getExpirationDates = () => {
            const dates = [];
            const now = new Date();
            
            for (let i = 1; i <= 12; i++) {
                const future = new Date(now);
                future.setDate(now.getDate() + (i * 7));
                dates.push({
                    label: i === 1 ? 'This Week' : `${i} Week${i > 1 ? 's' : ''}`,
                    value: `${i}week`,
                    date: future.toLocaleDateString(),
                    weeksOut: i
                });
            }
            
            return dates;
        };

        const expirationDates = getExpirationDates();

        // Handle search
        const handleSearch = async () => {
            if (!searchSymbol.trim()) return;
            
            setLoading(true);
            
            try {
                // Fetch real-time price
                const priceData = await fetchRealTimePrice(searchSymbol.toUpperCase());
                
                if (!priceData) {
                    alert('Invalid ticker symbol');
                    setLoading(false);
                    return;
                }
                
                // Generate historical prices for analysis
                const historicalPrices = Array.from({ length: 50 }, (_, i) => 
                    priceData.price * (1 + (Math.random() - 0.5) * 0.05)
                );
                
                // Generate max pain data for all expirations
                const maxPainByExpiration = {};
                expirationDates.forEach(exp => {
                    maxPainByExpiration[exp.value] = generateMaxPainData(priceData.price, exp.weeksOut);
                });
                
                // Detect patterns
                const patterns = detectPatterns(historicalPrices);
                
                // Calculate multi-timeframe RSI
                const rsiData = {
                    '5m': calculateRSI(historicalPrices.slice(-20)),
                    '15m': calculateRSI(historicalPrices.slice(-30)),
                    '1h': calculateRSI(historicalPrices.slice(-40)),
                    '4h': calculateRSI(historicalPrices),
                    '1d': calculateRSI(historicalPrices)
                };
                
                // Calculate MACD
                const macdData = calculateMACD(historicalPrices);
                
                // AI Prediction
                const aiPrediction = {
                    shortTerm: {
                        target: priceData.price * (1 + (Math.random() * 0.1 - 0.05)),
                        confidence: 75 + Math.random() * 20,
                        timeframe: '1-4 weeks'
                    },
                    mediumTerm: {
                        target: priceData.price * (1 + (Math.random() * 0.15 - 0.075)),
                        confidence: 65 + Math.random() * 20,
                        timeframe: '3-6 months'
                    },
                    longTerm: {
                        target: priceData.price * (1 + (Math.random() * 0.25 - 0.125)),
                        confidence: 55 + Math.random() * 20,
                        timeframe: '6+ months'
                    }
                };
                
                setCurrentData({
                    symbol: searchSymbol.toUpperCase(),
                    priceData,
                    maxPainByExpiration,
                    patterns,
                    rsiData,
                    macdData,
                    aiPrediction,
                    historicalPrices
                });
                
                // Generate alert
                const selectedMaxPain = maxPainByExpiration[selectedExpiration];
                const delta = ((selectedMaxPain.maxPain - priceData.price) / priceData.price) * 100;
                
                if (Math.abs(delta) > 3) {
                    const newAlert = {
                        id: Date.now(),
                        symbol: searchSymbol.toUpperCase(),
                        type: delta > 0 ? 'bullish' : 'bearish',
                        message: `${searchSymbol.toUpperCase()} max pain ${Math.abs(delta).toFixed(2)}% ${delta > 0 ? 'above' : 'below'} current price`,
                        confidence: 70 + Math.random() * 25,
                        timestamp: new Date().toLocaleTimeString()
                    };
                    setAlerts(prev => [newAlert, ...prev.slice(0, 9)]);
                }
                
            } catch (error) {
                console.error('Search error:', error);
                alert('Error fetching data. Please try again.');
            } finally {
                setLoading(false);
            }
        };

        // Generate top opportunities on mount
        useEffect(() => {
            const generateOpportunities = async () => {
                const symbols = ['SPY', 'AAPL', 'TSLA', 'NVDA', 'MSFT', 'GOOGL', 'AMZN', 'META', 'BTC-USD', 'ETH-USD'];
                const opportunities = [];
                
                for (const symbol of symbols) {
                    try {
                        const priceData = await fetchRealTimePrice(symbol);
                        if (priceData) {
                            const maxPain = generateMaxPainData(priceData.price, 1);
                            const delta = ((maxPain.maxPain - priceData.price) / priceData.price) * 100;
                            
                            opportunities.push({
                                symbol,
                                currentPrice: priceData.price,
                                maxPain: maxPain.maxPain,
                                delta: delta,
                                bias: delta > 0 ? 'bullish' : 'bearish',
                                confidence: 65 + Math.abs(delta) * 2
                            });
                        }
                    } catch (error) {
                        console.error(`Error fetching ${symbol}:`, error);
                    }
                }
                
                setTopOpportunities(opportunities.sort((a, b) => Math.abs(b.delta) - Math.abs(a.delta)).slice(0, 10));
            };
            
            generateOpportunities();
        }, []);

        // Dashboard View
        const DashboardView = () => (
            <div>
                <div className="search-container">
                    <input
                        type="text"
                        className="search-input"
                        placeholder="Enter ticker symbol (e.g., GME, AAPL, BTC-USD)"
                        value={searchSymbol}
                        onChange={(e) => setSearchSymbol(e.target.value.toUpperCase())}
                        onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
                    />
                    <button className="btn btn-primary" onClick={handleSearch}>
                        <Search size={20} />
                        Analyze
                    </button>
                </div>

                {loading && (
                    <div className="loading">
                        <div className="spinner"></div>
                    </div>
                )}

                {currentData && (
                    <div>
                        <div className="stats-grid">
                            <div className="stat-card">
                                <div className="stat-label">Current Price</div>
                                <div className="stat-value">${currentData.priceData.price.toFixed(2)}</div>
                                <div className={`stat-change ${currentData.priceData.change >= 0 ? 'positive' : 'negative'}`}>
                                    {currentData.priceData.change >= 0 ? '‚ñ≤' : '‚ñº'} ${Math.abs(currentData.priceData.change).toFixed(2)} ({currentData.priceData.changePercent.toFixed(2)}%)
                                </div>
                            </div>
                            
                            <div className="stat-card">
                                <div className="stat-label">Max Pain (Selected)</div>
                                <div className="stat-value">${currentData.maxPainByExpiration[selectedExpiration].maxPain.toFixed(2)}</div>
                                <div className={`stat-change ${((currentData.maxPainByExpiration[selectedExpiration].maxPain - currentData.priceData.price) >= 0) ? 'positive' : 'negative'}`}>
                                    {((currentData.maxPainByExpiration[selectedExpiration].maxPain - currentData.priceData.price) / currentData.priceData.price * 100).toFixed(2)}% Delta
                                </div>
                            </div>
                            
                            <div className="stat-card">
                                <div className="stat-label">Put/Call Ratio</div>
                                <div className="stat-value">{currentData.maxPainByExpiration[selectedExpiration].putCallRatio.toFixed(2)}</div>
                                <div className={`stat-change ${currentData.maxPainByExpiration[selectedExpiration].putCallRatio > 1 ? 'negative' : 'positive'}`}>
                                    {currentData.maxPainByExpiration[selectedExpiration].putCallRatio > 1 ? 'Bearish' : 'Bullish'} Bias
                                </div>
                            </div>
                            
                            <div className="stat-card">
                                <div className="stat-label">AI Confidence</div>
                                <div className="stat-value">{currentData.aiPrediction.shortTerm.confidence.toFixed(0)}%</div>
                                <div className="stat-change">Short-term Prediction</div>
                            </div>
                        </div>

                        <div className="card">
                            <div className="card-header">
                                <span>Expiration Dates</span>
                            </div>
                            <div className="expiration-tabs">
                                {expirationDates.map(exp => (
                                    <div
                                        key={exp.value}
                                        className={`expiration-tab ${selectedExpiration === exp.value ? 'active' : ''}`}
                                        onClick={() => setSelectedExpiration(exp.value)}
                                    >
                                        {exp.label}<br/>
                                        <small>{exp.date}</small>
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="card">
                            <div className="card-header">
                                <span>üìä Open Interest Distribution</span>
                            </div>
                            <div className="chart-container">
                                <canvas id="oiChart"></canvas>
                            </div>
                        </div>

                        <div className="card">
                            <div className="card-header">
                                <span>üéØ AI Price Predictions</span>
                            </div>
                            <div className="stats-grid">
                                <div className="stat-card">
                                    <div className="stat-label">Short Term (1-4 weeks)</div>
                                    <div className="stat-value">${currentData.aiPrediction.shortTerm.target.toFixed(2)}</div>
                                    <div className="stat-change positive">
                                        {currentData.aiPrediction.shortTerm.confidence.toFixed(0)}% Confidence
                                    </div>
                                </div>
                                <div className="stat-card">
                                    <div className="stat-label">Medium Term (3-6 months)</div>
                                    <div className="stat-value">${currentData.aiPrediction.mediumTerm.target.toFixed(2)}</div>
                                    <div className="stat-change positive">
                                        {currentData.aiPrediction.mediumTerm.confidence.toFixed(0)}% Confidence
                                    </div>
                                </div>
                                <div className="stat-card">
                                    <div className="stat-label">Long Term (6+ months)</div>
                                    <div className="stat-value">${currentData.aiPrediction.longTerm.target.toFixed(2)}</div>
                                    <div className="stat-change positive">
                                        {currentData.aiPrediction.longTerm.confidence.toFixed(0)}% Confidence
                                    </div>
                                </div>
                            </div>
                        </div>

                        {currentData.patterns.length > 0 && (
                            <div className="card">
                                <div className="card-header">
                                    <span>üîç Detected Patterns</span>
                                </div>
                                <div className="pattern-grid">
                                    {currentData.patterns.map((pattern, idx) => (
                                        <div key={idx} className="pattern-card">
                                            <div className="pattern-header">
                                                <div className="pattern-name">{pattern.name}</div>
                                                <span className={`badge badge-${pattern.type === 'bullish' ? 'bullish' : 'bearish'}`}>
                                                    {pattern.type}
                                                </span>
                                            </div>
                                            <div className="confidence-score positive">
                                                {pattern.confidence.toFixed(0)}%
                                            </div>
                                            <div style={{marginTop: '1rem', fontSize: '0.9rem', color: 'var(--text-secondary)'}}>
                                                Target: ${pattern.target.toFixed(2)}<br/>
                                                Stop: ${pattern.stop.toFixed(2)}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                )}

                <div className="card">
                    <div className="card-header">
                        <span>üî• Top 10 Trading Opportunities</span>
                    </div>
                    {topOpportunities.length > 0 ? (
                        <table className="data-table">
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Current Price</th>
                                    <th>Max Pain</th>
                                    <th>Delta %</th>
                                    <th>Bias</th>
                                    <th>Confidence</th>
                                </tr>
                            </thead>
                            <tbody>
                                {topOpportunities.map((opp, idx) => (
                                    <tr key={idx}>
                                        <td><strong>{opp.symbol}</strong></td>
                                        <td>${opp.currentPrice.toFixed(2)}</td>
                                        <td>${opp.maxPain.toFixed(2)}</td>
                                        <td className={opp.delta >= 0 ? 'positive' : 'negative'}>
                                            {opp.delta >= 0 ? '‚ñ≤' : '‚ñº'} {Math.abs(opp.delta).toFixed(2)}%
                                        </td>
                                        <td>
                                            <span className={`badge badge-${opp.bias}`}>
                                                {opp.bias}
                                            </span>
                                        </td>
                                        <td>{opp.confidence.toFixed(0)}%</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    ) : (
                        <div className="loading">Loading opportunities...</div>
                    )}
                </div>
            </div>
        );

        // Crypto Multi-Timeframe View
        const CryptoView = () => {
            const [cryptoSymbol, setCryptoSymbol] = useState('BTC-USD');
            const [cryptoData, setCryptoData] = useState(null);

            const analyzeCrypto = async () => {
                setLoading(true);
                try {
                    const priceData = await fetchRealTimePrice(cryptoSymbol);
                    if (!priceData) {
                        alert('Invalid crypto symbol');
                        setLoading(false);
                        return;
                    }

                    const historicalPrices = Array.from({ length: 100 }, (_, i) => 
                        priceData.price * (1 + (Math.random() - 0.5) * 0.1)
                    );

                    const timeframes = ['5m', '15m', '1h', '4h', '1d'];
                    const analysis = {};

                    timeframes.forEach(tf => {
                        const prices = historicalPrices.slice(-(timeframes.indexOf(tf) + 1) * 20);
                        analysis[tf] = {
                            rsi: calculateRSI(prices),
                            macd: calculateMACD(prices),
                            trend: prices[prices.length - 1] > prices[0] ? 'Bullish' : 'Bearish'
                        };
                    });

                    setCryptoData({
                        symbol: cryptoSymbol,
                        priceData,
                        analysis
                    });
                } catch (error) {
                    console.error('Crypto analysis error:', error);
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div>
                    <div className="search-container">
                        <input
                            type="text"
                            className="search-input"
                            placeholder="Enter crypto symbol (e.g., BTC-USD, ETH-USD)"
                            value={cryptoSymbol}
                            onChange={(e) => setCryptoSymbol(e.target.value.toUpperCase())}
                            onKeyPress={(e) => e.key === 'Enter' && analyzeCrypto()}
                        />
                        <button className="btn btn-primary" onClick={analyzeCrypto}>
                            <Activity size={20} />
                            Analyze Crypto
                        </button>
                    </div>

                    {loading && <div className="loading"><div className="spinner"></div></div>}

                    {cryptoData && (
                        <div>
                            <div className="stats-grid">
                                <div className="stat-card">
                                    <div className="stat-label">Current Price</div>
                                    <div className="stat-value">${cryptoData.priceData.price.toFixed(2)}</div>
                                    <div className={`stat-change ${cryptoData.priceData.change >= 0 ? 'positive' : 'negative'}`}>
                                        {cryptoData.priceData.change >= 0 ? '‚ñ≤' : '‚ñº'} {cryptoData.priceData.changePercent.toFixed(2)}%
                                    </div>
                                </div>
                            </div>

                            <div className="card">
                                <div className="card-header">
                                    <span>üìà Multi-Timeframe Analysis</span>
                                </div>
                                <div className="timeframe-grid">
                                    {Object.entries(cryptoData.analysis).map(([tf, data]) => (
                                        <div key={tf} className="timeframe-card">
                                            <div className="timeframe-header">{tf.toUpperCase()}</div>
                                            <div className="indicator-row">
                                                <span className="indicator-label">RSI</span>
                                                <span className={`indicator-value ${data.rsi < 30 ? 'positive' : data.rsi > 70 ? 'negative' : ''}`}>
                                                    {data.rsi.toFixed(2)}
                                                </span>
                                            </div>
                                            <div className="indicator-row">
                                                <span className="indicator-label">MACD</span>
                                                <span className={`indicator-value ${data.macd.histogram > 0 ? 'positive' : 'negative'}`}>
                                                    {data.macd.macd.toFixed(4)}
                                                </span>
                                            </div>
                                            <div className="indicator-row">
                                                <span className="indicator-label">Trend</span>
                                                <span className={`badge badge-${data.trend === 'Bullish' ? 'bullish' : 'bearish'}`}>
                                                    {data.trend}
                                                </span>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Alerts View
        const AlertsView = () => (
            <div>
                <div className="card">
                    <div className="card-header">
                        <span>üîî Recent Alerts</span>
                    </div>
                    {alerts.length > 0 ? (
                        alerts.map(alert => (
                            <div key={alert.id} className={`alert alert-${alert.type === 'bullish' ? 'success' : 'warning'}`}>
                                <div>
                                    <strong>{alert.symbol}</strong> - {alert.message}
                                    <div style={{fontSize: '0.85rem', color: 'var(--text-secondary)', marginTop: '0.5rem'}}>
                                        Confidence: {alert.confidence.toFixed(0)}% | {alert.timestamp}
                                    </div>
                                </div>
                            </div>
                        ))
                    ) : (
                        <div style={{textAlign: 'center', padding: '2rem', color: 'var(--text-secondary)'}}>
                            No alerts yet. Start analyzing symbols to generate alerts.
                        </div>
                    )}
                </div>
            </div>
        );

        // Render charts after data loads
        useEffect(() => {
            if (currentData && document.getElementById('oiChart')) {
                const ctx = document.getElementById('oiChart').getContext('2d');
                const maxPainData = currentData.maxPainByExpiration[selectedExpiration];
                
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: maxPainData.strikes.map(s => s.strike),
                        datasets: [
                            {
                                label: 'Call OI',
                                data: maxPainData.strikes.map(s => s.callOI),
                                backgroundColor: 'rgba(0, 255, 136, 0.5)',
                            },
                            {
                                label: 'Put OI',
                                data: maxPainData.strikes.map(s => s.putOI),
                                backgroundColor: 'rgba(255, 51, 102, 0.5)',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#e8eaed' }
                            }
                        },
                        scales: {
                            x: { ticks: { color: '#a0a4a8' } },
                            y: { ticks: { color: '#a0a4a8' } }
                        }
                    }
                });
            }
        }, [currentData, selectedExpiration]);

        return (
            <div className="app-container">
                <header className="header">
                    <div className="logo">‚ö° MaxPain Pro</div>
                    <nav className="nav-tabs">
                        <button className={`nav-tab ${activeTab === 'dashboard' ? 'active' : ''}`} onClick={() => setActiveTab('dashboard')}>
                            <BarChart3 size={18} /> Dashboard
                        </button>
                        <button className={`nav-tab ${activeTab === 'crypto' ? 'active' : ''}`} onClick={() => setActiveTab('crypto')}>
                            <Activity size={18} /> Crypto Analysis
                        </button>
                        <button className={`nav-tab ${activeTab === 'alerts' ? 'active' : ''}`} onClick={() => setActiveTab('alerts')}>
                            <AlertTriangle size={18} /> Alerts
                        </button>
                    </nav>
                </header>
                
                <main className="main-content">
                    {activeTab === 'dashboard' && <DashboardView />}
                    {activeTab === 'crypto' && <CryptoView />}
                    {activeTab === 'alerts' && <AlertsView />}
                </main>
            </div>
        );
    };

    ReactDOM.render(<TradingApp />, document.getElementById('root'));
</script>
```

</body>
</html>
